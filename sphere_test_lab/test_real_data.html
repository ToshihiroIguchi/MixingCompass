<!DOCTYPE html>
<html>
<head>
    <title>MixingCompass Real Data Test</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-container { margin-bottom: 40px; border: 1px solid #ccc; padding: 20px; }
        .plot-container { width: 600px; height: 400px; margin: 10px 0; }
        h2 { color: #333; }
        .description { color: #666; margin-bottom: 10px; }
        .data-info { background: #f0f0f0; padding: 10px; margin: 10px 0; font-family: monospace; }
    </style>
</head>
<body>
    <h1>MixingCompass Real Data Test</h1>

    <div class="test-container">
        <h2>Test: Fetch Real Data from MixingCompass</h2>
        <button onclick="fetchRealData()">Fetch Current Hansen Sphere Data</button>
        <div id="dataInfo" class="data-info">Click button to fetch real data...</div>
    </div>

    <div class="test-container">
        <h2>Real Data - Surface Plot</h2>
        <div class="description">Using actual MixingCompass data</div>
        <div id="plotReal" class="plot-container"></div>
    </div>

    <div class="test-container">
        <h2>Real Data - Normalized</h2>
        <div class="description">Same data but normalized to [-1,1]</div>
        <div id="plotNormalized" class="plot-container"></div>
    </div>

    <div class="test-container">
        <h2>Real Data - Wireframe</h2>
        <div class="description">Same data as wireframe only</div>
        <div id="plotWireframe" class="plot-container"></div>
    </div>

    <script>
        let realData = null;

        async function fetchRealData() {
            try {
                // Try to fetch from the running MixingCompass server
                const response = await fetch('http://localhost:8200/api/hsp-experimental/test-sphere-patterns');
                if (response.ok) {
                    realData = await response.json();
                    document.getElementById('dataInfo').innerHTML = `
                        <strong>Real Data Found:</strong><br>
                        Center: (${realData.test_center[0]}, ${realData.test_center[1]}, ${realData.test_center[2]})<br>
                        Radius: ${realData.test_radius}<br>
                        Patterns available: ${Object.keys(realData.patterns).length}
                    `;

                    // Use the center and radius from real data
                    testWithRealData(realData.test_center, realData.test_radius);
                } else {
                    // Fallback to typical HSP values
                    const fallbackCenter = [15.6, 8.1, 13.0];
                    const fallbackRadius = 6.5;
                    document.getElementById('dataInfo').innerHTML = `
                        <strong>Using Fallback Data:</strong><br>
                        Center: (${fallbackCenter[0]}, ${fallbackCenter[1]}, ${fallbackCenter[2]})<br>
                        Radius: ${fallbackRadius}<br>
                        (Could not fetch from server)
                    `;
                    testWithRealData(fallbackCenter, fallbackRadius);
                }
            } catch (error) {
                // Use typical HSP values as fallback
                const fallbackCenter = [15.6, 8.1, 13.0];
                const fallbackRadius = 6.5;
                document.getElementById('dataInfo').innerHTML = `
                    <strong>Using Fallback Data (No Server):</strong><br>
                    Center: (${fallbackCenter[0]}, ${fallbackCenter[1]}, ${fallbackCenter[2]})<br>
                    Radius: ${fallbackRadius}<br>
                    Error: ${error.message}
                `;
                testWithRealData(fallbackCenter, fallbackRadius);
            }
        }

        function testWithRealData(center, radius) {
            // Add some typical solvent points like in real app
            const solventPoints = [
                { name: 'acetone', coords: [15.5, 10.4, 7.0], color: '#1976d2' },
                { name: 'ethanol', coords: [15.8, 8.8, 19.4], color: '#1976d2' },
                { name: 'hexane', coords: [14.9, 0, 0], color: '#d32f2f' },
                { name: 'toluene', coords: [18.0, 1.4, 2.0], color: '#d32f2f' }
            ];

            // Test 1: Original scale with all elements (like real app)
            plotRealScale(center, radius, solventPoints);

            // Test 2: Normalized scale
            plotNormalizedScale(center, radius, solventPoints);

            // Test 3: Wireframe only
            plotWireframeOnly(center, radius, solventPoints);
        }

        function generateSphereSurface(center, radius, resolution = 20) {
            const x = [];
            const y = [];
            const z = [];

            for (let i = 0; i < resolution; i++) {
                const xRow = [];
                const yRow = [];
                const zRow = [];
                for (let j = 0; j < resolution; j++) {
                    const u = 2 * Math.PI * j / (resolution - 1);
                    const v = Math.PI * i / (resolution - 1);

                    xRow.push(center[0] + radius * Math.cos(u) * Math.sin(v));
                    yRow.push(center[1] + radius * Math.sin(u) * Math.sin(v));
                    zRow.push(center[2] + radius * Math.cos(v));
                }
                x.push(xRow);
                y.push(yRow);
                z.push(zRow);
            }

            return { x, y, z };
        }

        function generateSphereWireframe(center, radius, resolution = 30) {
            const x = [];
            const y = [];
            const z = [];

            // Meridians
            const nMeridians = 12;
            for (let i = 0; i < nMeridians; i++) {
                const phi = 2 * Math.PI * i / nMeridians;
                for (let j = 0; j < resolution; j++) {
                    const theta = Math.PI * j / (resolution - 1);
                    x.push(center[0] + radius * Math.sin(theta) * Math.cos(phi));
                    y.push(center[1] + radius * Math.sin(theta) * Math.sin(phi));
                    z.push(center[2] + radius * Math.cos(theta));
                }
                x.push(null);
                y.push(null);
                z.push(null);
            }

            // Parallels
            const nParallels = 6;
            for (let i = 1; i < nParallels; i++) {
                const theta = Math.PI * i / nParallels;
                for (let j = 0; j < resolution; j++) {
                    const phi = 2 * Math.PI * j / (resolution - 1);
                    x.push(center[0] + radius * Math.sin(theta) * Math.cos(phi));
                    y.push(center[1] + radius * Math.sin(theta) * Math.sin(phi));
                    z.push(center[2] + radius * Math.cos(theta));
                }
                x.push(null);
                y.push(null);
                z.push(null);
            }

            return { x, y, z };
        }

        function normalizeData(center, radius, solventPoints) {
            // Collect all values to determine range
            const allValues = [
                ...center,
                center[0] - radius, center[0] + radius,
                center[1] - radius, center[1] + radius,
                center[2] - radius, center[2] + radius
            ];

            // Add solvent coordinates
            solventPoints.forEach(s => allValues.push(...s.coords));

            const globalMin = Math.min(...allValues);
            const globalMax = Math.max(...allValues);
            const globalRange = globalMax - globalMin;

            const normalize = (value) => 2 * (value - globalMin) / globalRange - 1;

            return {
                center: center.map(normalize),
                radius: 2 * radius / globalRange,
                solventPoints: solventPoints.map(s => ({
                    ...s,
                    coords: s.coords.map(normalize)
                })),
                originalRange: { min: globalMin, max: globalMax, range: globalRange }
            };
        }

        function plotRealScale(center, radius, solventPoints) {
            const sphereCoords = generateSphereSurface(center, radius);

            const traces = [];

            // Add sphere surface
            traces.push({
                type: 'surface',
                x: sphereCoords.x,
                y: sphereCoords.y,
                z: sphereCoords.z,
                colorscale: [[0, 'rgba(76, 175, 80, 0.3)'], [1, 'rgba(76, 175, 80, 0.3)']],
                opacity: 0.4,
                showscale: false,
                name: 'Hansen Sphere'
            });

            // Add solvent points
            const solventX = solventPoints.map(s => s.coords[0]);
            const solventY = solventPoints.map(s => s.coords[1]);
            const solventZ = solventPoints.map(s => s.coords[2]);
            const solventColors = solventPoints.map(s => s.color);

            traces.push({
                type: 'scatter3d',
                mode: 'markers',
                x: solventX,
                y: solventY,
                z: solventZ,
                marker: {
                    size: 5,
                    color: solventColors,
                    opacity: 0.9
                },
                text: solventPoints.map(s => s.name),
                name: 'Solvents'
            });

            // Add center point
            traces.push({
                type: 'scatter3d',
                mode: 'markers',
                x: [center[0]],
                y: [center[1]],
                z: [center[2]],
                marker: {
                    size: 6,
                    color: '#32CD32',
                    opacity: 1.0
                },
                name: 'HSP Center'
            });

            Plotly.newPlot('plotReal', traces, {
                scene: {
                    aspectmode: 'cube',
                    camera: { eye: { x: 1.25, y: 1.25, z: 1.25 } }
                },
                title: 'Real Scale Data (Current MixingCompass approach)'
            });
        }

        function plotNormalizedScale(center, radius, solventPoints) {
            const normalized = normalizeData(center, radius, solventPoints);
            const sphereCoords = generateSphereSurface(normalized.center, normalized.radius);

            const traces = [];

            // Add sphere surface
            traces.push({
                type: 'surface',
                x: sphereCoords.x,
                y: sphereCoords.y,
                z: sphereCoords.z,
                colorscale: [[0, 'rgba(76, 175, 80, 0.3)'], [1, 'rgba(76, 175, 80, 0.3)']],
                opacity: 0.4,
                showscale: false,
                name: 'Hansen Sphere'
            });

            // Add solvent points
            const solventX = normalized.solventPoints.map(s => s.coords[0]);
            const solventY = normalized.solventPoints.map(s => s.coords[1]);
            const solventZ = normalized.solventPoints.map(s => s.coords[2]);
            const solventColors = normalized.solventPoints.map(s => s.color);

            traces.push({
                type: 'scatter3d',
                mode: 'markers',
                x: solventX,
                y: solventY,
                z: solventZ,
                marker: {
                    size: 5,
                    color: solventColors,
                    opacity: 0.9
                },
                text: normalized.solventPoints.map(s => s.name),
                name: 'Solvents'
            });

            // Add center point
            traces.push({
                type: 'scatter3d',
                mode: 'markers',
                x: [normalized.center[0]],
                y: [normalized.center[1]],
                z: [normalized.center[2]],
                marker: {
                    size: 6,
                    color: '#32CD32',
                    opacity: 1.0
                },
                name: 'HSP Center'
            });

            Plotly.newPlot('plotNormalized', traces, {
                scene: {
                    aspectmode: 'cube',
                    camera: { eye: { x: 1.25, y: 1.25, z: 1.25 } }
                },
                title: 'Normalized Data (Should be perfect sphere)'
            });
        }

        function plotWireframeOnly(center, radius, solventPoints) {
            const wireframe = generateSphereWireframe(center, radius);

            const traces = [];

            // Add wireframe
            traces.push({
                type: 'scatter3d',
                mode: 'lines',
                x: wireframe.x,
                y: wireframe.y,
                z: wireframe.z,
                line: {
                    color: 'rgba(76, 175, 80, 0.7)',
                    width: 3
                },
                showlegend: false,
                name: 'Hansen Sphere'
            });

            // Add solvent points
            const solventX = solventPoints.map(s => s.coords[0]);
            const solventY = solventPoints.map(s => s.coords[1]);
            const solventZ = solventPoints.map(s => s.coords[2]);
            const solventColors = solventPoints.map(s => s.color);

            traces.push({
                type: 'scatter3d',
                mode: 'markers',
                x: solventX,
                y: solventY,
                z: solventZ,
                marker: {
                    size: 5,
                    color: solventColors,
                    opacity: 0.9
                },
                text: solventPoints.map(s => s.name),
                name: 'Solvents'
            });

            // Add center point
            traces.push({
                type: 'scatter3d',
                mode: 'markers',
                x: [center[0]],
                y: [center[1]],
                z: [center[2]],
                marker: {
                    size: 6,
                    color: '#32CD32',
                    opacity: 1.0
                },
                name: 'HSP Center'
            });

            Plotly.newPlot('plotWireframe', traces, {
                scene: {
                    aspectmode: 'cube',
                    camera: { eye: { x: 1.25, y: 1.25, z: 1.25 } }
                },
                title: 'Wireframe Only (No surface distortion possible)'
            });
        }

        // Auto-fetch data on page load
        window.onload = () => {
            fetchRealData();
        };
    </script>
</body>
</html>