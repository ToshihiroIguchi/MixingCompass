<!DOCTYPE html>
<html>
<head>
    <title>Real Data Sphere Debug</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 1400px; margin: 0 auto; }
        .test-section { margin-bottom: 30px; border: 1px solid #ccc; padding: 20px; }
        .plot-container { width: 700px; height: 500px; margin: 10px 0; }
        .comparison { display: flex; gap: 20px; }
        .analysis { background: #f0f0f0; padding: 15px; margin: 10px 0; font-family: monospace; font-size: 12px; white-space: pre-line; }
        button { padding: 10px 20px; margin: 5px; background: #007cba; color: white; border: none; cursor: pointer; }
        button:hover { background: #005a87; }
        .highlight { background: yellow; font-weight: bold; }
        .error { color: red; font-weight: bold; }
        .success { color: green; font-weight: bold; }
        .json-viewer { max-height: 300px; overflow-y: scroll; border: 1px solid #ccc; padding: 10px; font-size: 11px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Real MixingCompass Data Sphere Debug</h1>

        <div class="test-section">
            <h2>Step 1: Fetch Current Visualization Data</h2>
            <button onclick="fetchCurrentData()">Fetch Real Data from MixingCompass</button>
            <div id="fetchStatus" class="analysis">Click button to start...</div>
        </div>

        <div class="test-section">
            <h2>Step 2: Data Analysis</h2>
            <div id="dataAnalysis" class="analysis">No data yet...</div>
        </div>

        <div class="comparison">
            <div class="test-section">
                <h2>Current (Raw Server Data)</h2>
                <div class="analysis" id="currentInfo">Plot using exact server data...</div>
                <div id="plotCurrent" class="plot-container"></div>
            </div>

            <div class="test-section">
                <h2>Modified (Fixed Ranges)</h2>
                <div class="analysis" id="fixedInfo">Same data with corrected ranges...</div>
                <div id="plotFixed" class="plot-container"></div>
            </div>
        </div>

        <div class="test-section">
            <h2>Raw JSON Response</h2>
            <div id="jsonData" class="json-viewer">No data yet...</div>
        </div>
    </div>

    <script>
        let currentData = null;

        async function fetchCurrentData() {
            try {
                document.getElementById('fetchStatus').textContent = 'Fetching experiments list...';

                // First get available experiments
                const experimentsResponse = await fetch('http://localhost:8200/api/hsp-experimental/experiments');
                if (!experimentsResponse.ok) {
                    throw new Error(`Failed to fetch experiments: ${experimentsResponse.status}`);
                }

                const experimentsData = await experimentsResponse.json();
                if (!experimentsData.experiments || experimentsData.experiments.length === 0) {
                    throw new Error('No experiments found. Please create an experiment first.');
                }

                // Use the first (most recent) experiment
                const experiment = experimentsData.experiments[0];
                const experimentId = experiment.id;

                document.getElementById('fetchStatus').textContent = `Found experiment: ${experimentId}\nFetching visualization data...`;

                // Fetch visualization data
                const vizResponse = await fetch(`http://localhost:8200/api/hsp-experimental/experiments/${experimentId}/visualization?width=890&height=600`);
                if (!vizResponse.ok) {
                    throw new Error(`Failed to fetch visualization: ${vizResponse.status}`);
                }

                currentData = await vizResponse.json();

                document.getElementById('fetchStatus').innerHTML = `
<span class="success">✅ Data fetched successfully!</span>
Experiment ID: ${experimentId}
Data size: ${JSON.stringify(currentData).length} characters
Created: ${experiment.created_at}
                `;

                analyzeData();
                plotCurrentData();
                plotFixedData();
                showJsonData();

            } catch (error) {
                document.getElementById('fetchStatus').innerHTML = `
<span class="error">❌ Error: ${error.message}</span>

Make sure:
1. MixingCompass server is running on port 8200
2. At least one experiment exists (create one in the main UI)
3. The experiment has been calculated
                `;
            }
        }

        function analyzeData() {
            if (!currentData) return;

            let analysis = 'Data Structure Analysis:\n\n';

            // Verify Plotly format
            if (currentData.data && currentData.layout) {
                analysis += '✅ Valid Plotly format detected\n';
                analysis += `Number of traces: ${currentData.data.length}\n\n`;

                // Analyze each trace
                let sphereTrace = null;
                let solventTrace = null;
                let centerTrace = null;

                currentData.data.forEach((trace, i) => {
                    analysis += `Trace ${i}: ${trace.type} - ${trace.name || 'unnamed'}\n`;

                    if (trace.name === 'Hansen Sphere') {
                        sphereTrace = trace;
                        analysis += `  Surface data: ${trace.x ? trace.x.length : 'undefined'} x ${trace.y ? trace.y.length : 'undefined'} grid\n`;
                    } else if (trace.name === 'Solvent Points') {
                        solventTrace = trace;
                        analysis += `  Solvent points: ${trace.x ? trace.x.length : 0} points\n`;
                    } else if (trace.name === 'Hansen Center') {
                        centerTrace = trace;
                        analysis += `  Center point: (${trace.x ? trace.x[0] : 'N/A'}, ${trace.y ? trace.y[0] : 'N/A'}, ${trace.z ? trace.z[0] : 'N/A'})\n`;
                    }
                });

                // Analyze layout
                analysis += '\nLayout Settings:\n';
                if (currentData.layout.scene) {
                    const scene = currentData.layout.scene;
                    analysis += `aspectmode: ${scene.aspectmode || 'undefined'}\n`;

                    if (scene.aspectratio) {
                        analysis += `aspectratio: x=${scene.aspectratio.x}, y=${scene.aspectratio.y}, z=${scene.aspectratio.z}\n`;
                    }

                    // Check axis ranges
                    ['xaxis', 'yaxis', 'zaxis'].forEach(axis => {
                        if (scene[axis] && scene[axis].range) {
                            const range = scene[axis].range;
                            const span = range[1] - range[0];
                            analysis += `${axis}: [${range[0].toFixed(2)}, ${range[1].toFixed(2)}] (span: ${span.toFixed(2)})\n`;
                        }
                    });
                }

                // Calculate sphere data ranges if available
                if (sphereTrace && sphereTrace.type === 'surface') {
                    analysis += '\nSphere Data Analysis:\n';
                    const xFlat = sphereTrace.x.flat();
                    const yFlat = sphereTrace.y.flat();
                    const zFlat = sphereTrace.z.flat();

                    const xRange = [Math.min(...xFlat), Math.max(...xFlat)];
                    const yRange = [Math.min(...yFlat), Math.max(...yFlat)];
                    const zRange = [Math.min(...zFlat), Math.max(...zFlat)];

                    const xSpan = xRange[1] - xRange[0];
                    const ySpan = yRange[1] - yRange[0];
                    const zSpan = zRange[1] - zRange[0];

                    analysis += `Sphere X: [${xRange[0].toFixed(2)}, ${xRange[1].toFixed(2)}] (span: ${xSpan.toFixed(2)})\n`;
                    analysis += `Sphere Y: [${yRange[0].toFixed(2)}, ${yRange[1].toFixed(2)}] (span: ${ySpan.toFixed(2)})\n`;
                    analysis += `Sphere Z: [${zRange[0].toFixed(2)}, ${zRange[1].toFixed(2)}] (span: ${zSpan.toFixed(2)})\n`;

                    // Check if spans are equal
                    const maxSpan = Math.max(xSpan, ySpan, zSpan);
                    const minSpan = Math.min(xSpan, ySpan, zSpan);
                    const spanDifference = maxSpan - minSpan;

                    if (spanDifference < 0.1) {
                        analysis += `\n✅ Sphere spans are equal (difference: ${spanDifference.toFixed(3)})\n`;
                    } else {
                        analysis += `\n⚠️ Sphere spans are unequal (difference: ${spanDifference.toFixed(3)})\n`;
                        analysis += `This WILL cause distortion!\n`;
                    }

                    // Check axis ranges vs sphere spans
                    if (currentData.layout.scene.xaxis && currentData.layout.scene.xaxis.range) {
                        const layoutXSpan = currentData.layout.scene.xaxis.range[1] - currentData.layout.scene.xaxis.range[0];
                        const layoutYSpan = currentData.layout.scene.yaxis.range[1] - currentData.layout.scene.yaxis.range[0];
                        const layoutZSpan = currentData.layout.scene.zaxis.range[1] - currentData.layout.scene.zaxis.range[0];

                        analysis += `\nAxis Range Spans:\n`;
                        analysis += `Layout X span: ${layoutXSpan.toFixed(2)}\n`;
                        analysis += `Layout Y span: ${layoutYSpan.toFixed(2)}\n`;
                        analysis += `Layout Z span: ${layoutZSpan.toFixed(2)}\n`;

                        const maxLayoutSpan = Math.max(layoutXSpan, layoutYSpan, layoutZSpan);
                        const minLayoutSpan = Math.min(layoutXSpan, layoutYSpan, layoutZSpan);
                        const layoutSpanDiff = maxLayoutSpan - minLayoutSpan;

                        if (layoutSpanDiff < 0.1) {
                            analysis += `✅ Layout spans are equal (difference: ${layoutSpanDiff.toFixed(3)})\n`;
                        } else {
                            analysis += `❌ Layout spans are unequal (difference: ${layoutSpanDiff.toFixed(3)})\n`;
                            analysis += `This is the CAUSE of distortion!\n`;
                        }
                    }
                }

            } else {
                analysis += '❌ Invalid data format - not standard Plotly\n';
            }

            document.getElementById('dataAnalysis').textContent = analysis;
        }

        function plotCurrentData() {
            if (!currentData) return;

            try {
                // Plot using exact server data
                Plotly.newPlot('plotCurrent', currentData.data, currentData.layout);

                document.getElementById('currentInfo').textContent = `
Current Server Data:
• aspectmode: ${currentData.layout.scene?.aspectmode || 'undefined'}
• aspectratio: ${JSON.stringify(currentData.layout.scene?.aspectratio || 'undefined')}
• Uses server-generated axis ranges
                `;
            } catch (error) {
                document.getElementById('plotCurrent').innerHTML = `<span class="error">Error: ${error.message}</span>`;
            }
        }

        function plotFixedData() {
            if (!currentData) return;

            try {
                // Create fixed version with equal ranges
                const fixedLayout = JSON.parse(JSON.stringify(currentData.layout));

                // Force cube mode
                if (fixedLayout.scene) {
                    fixedLayout.scene.aspectmode = 'cube';

                    // Remove manual ranges to let cube mode work
                    if (fixedLayout.scene.xaxis) delete fixedLayout.scene.xaxis.range;
                    if (fixedLayout.scene.yaxis) delete fixedLayout.scene.yaxis.range;
                    if (fixedLayout.scene.zaxis) delete fixedLayout.scene.zaxis.range;
                }

                fixedLayout.title = (fixedLayout.title?.text || 'Hansen Sphere') + ' - FIXED (cube mode)';

                Plotly.newPlot('plotFixed', currentData.data, fixedLayout);

                document.getElementById('fixedInfo').textContent = `
Fixed Version:
• aspectmode: cube (overrides manual ranges)
• aspectratio: removed (cube mode handles this)
• Axis ranges: removed (cube mode calculates equal ranges)
                `;
            } catch (error) {
                document.getElementById('plotFixed').innerHTML = `<span class="error">Error: ${error.message}</span>`;
            }
        }

        function showJsonData() {
            if (!currentData) return;

            const jsonString = JSON.stringify(currentData, null, 2);
            document.getElementById('jsonData').innerHTML = `<pre>${jsonString}</pre>`;
        }
    </script>
</body>
</html>