<!DOCTYPE html>
<html>
<head>
    <title>Comprehensive Hansen Sphere Test</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .test-container { border: 1px solid #ccc; padding: 15px; }
        .plot-container { width: 100%; height: 400px; margin: 10px 0; }
        .analysis { background: #f0f0f0; padding: 10px; margin: 10px 0; font-family: monospace; font-size: 11px; }
        h2 { color: #333; margin-top: 0; }
        .controls { margin: 10px 0; }
        button { padding: 8px 15px; margin: 5px; background: #007cba; color: white; border: none; cursor: pointer; }
        button:hover { background: #005a87; }
        .highlight { background: yellow; font-weight: bold; }
    </style>
</head>
<body>
    <h1>Comprehensive Hansen Sphere Distortion Test</h1>

    <div class="controls">
        <button onclick="runAllTests()">Run All Tests</button>
        <button onclick="testMixingCompassExact()">Test MixingCompass Exact Data</button>
        <button onclick="generateReport()">Generate Analysis Report</button>
    </div>

    <div id="analysis" class="analysis">
        Click "Run All Tests" to begin comprehensive analysis...
    </div>

    <div class="test-grid">
        <div class="test-container">
            <h2>Test 1: MixingCompass Simulation</h2>
            <div class="analysis" id="test1-info">Simulating exact MixingCompass conditions</div>
            <div id="plot1" class="plot-container"></div>
        </div>

        <div class="test-container">
            <h2>Test 2: Equal Ranges (Manual)</h2>
            <div class="analysis" id="test2-info">Manual aspectmode with equal axis ranges</div>
            <div id="plot2" class="plot-container"></div>
        </div>

        <div class="test-container">
            <h2>Test 3: Cube Mode</h2>
            <div class="analysis" id="test3-info">aspectmode: 'cube' with real data</div>
            <div id="plot3" class="plot-container"></div>
        </div>

        <div class="test-container">
            <h2>Test 4: Data Mode + Invisible Points</h2>
            <div class="analysis" id="test4-info">aspectmode: 'data' with boundary points</div>
            <div id="plot4" class="plot-container"></div>
        </div>

        <div class="test-container">
            <h2>Test 5: Normalized Coordinates</h2>
            <div class="analysis" id="test5-info">Full data normalization to [-1,1]</div>
            <div id="plot5" class="plot-container"></div>
        </div>

        <div class="test-container">
            <h2>Test 6: Wireframe Only</h2>
            <div class="analysis" id="test6-info">Lines only (no surface distortion)</div>
            <div id="plot6" class="plot-container"></div>
        </div>
    </div>

    <div id="report" class="analysis" style="margin-top: 20px; display: none;">
        <h3>Analysis Report</h3>
        <div id="reportContent"></div>
    </div>

    <script>
        // Exact MixingCompass data from server response
        const realData = {
            center: [15.600000000000003, 8.066666666666668, 13.0],
            radius: 6.45428367658083,
            solvents: [
                { name: 'acetone', coords: [15.5, 10.4, 7.0], solubility: 'soluble', color: '#1976d2' },
                { name: 'ethanol', coords: [15.8, 8.8, 19.4], solubility: 'soluble', color: '#1976d2' },
                { name: 'ethyl acetate', coords: [15.8, 5.3, 7.2], solubility: 'partial', color: '#ff9800' },
                { name: 'hexane', coords: [14.9, 0, 0], solubility: 'insoluble', color: '#d32f2f' },
                { name: 'toluene', coords: [18.0, 1.4, 2.0], solubility: 'insoluble', color: '#d32f2f' }
            ]
        };

        let testResults = {};

        // Generate sphere surface
        function generateSphere(center, radius, resolution = 20) {
            const x = [];
            const y = [];
            const z = [];

            for (let i = 0; i < resolution; i++) {
                const xRow = [];
                const yRow = [];
                const zRow = [];
                for (let j = 0; j < resolution; j++) {
                    const u = 2 * Math.PI * j / (resolution - 1);
                    const v = Math.PI * i / (resolution - 1);

                    xRow.push(center[0] + radius * Math.cos(u) * Math.sin(v));
                    yRow.push(center[1] + radius * Math.sin(u) * Math.sin(v));
                    zRow.push(center[2] + radius * Math.cos(v));
                }
                x.push(xRow);
                y.push(yRow);
                z.push(zRow);
            }

            return { x, y, z };
        }

        // Generate wireframe
        function generateWireframe(center, radius, resolution = 30) {
            const x = [];
            const y = [];
            const z = [];

            // Meridians
            const nMeridians = 12;
            for (let i = 0; i < nMeridians; i++) {
                const phi = 2 * Math.PI * i / nMeridians;
                for (let j = 0; j < resolution; j++) {
                    const theta = Math.PI * j / (resolution - 1);
                    x.push(center[0] + radius * Math.sin(theta) * Math.cos(phi));
                    y.push(center[1] + radius * Math.sin(theta) * Math.sin(phi));
                    z.push(center[2] + radius * Math.cos(theta));
                }
                x.push(null);
                y.push(null);
                z.push(null);
            }

            // Parallels
            const nParallels = 6;
            for (let i = 1; i < nParallels; i++) {
                const theta = Math.PI * i / nParallels;
                for (let j = 0; j < resolution; j++) {
                    const phi = 2 * Math.PI * j / (resolution - 1);
                    x.push(center[0] + radius * Math.sin(theta) * Math.cos(phi));
                    y.push(center[1] + radius * Math.sin(theta) * Math.sin(phi));
                    z.push(center[2] + radius * Math.cos(theta));
                }
                x.push(null);
                y.push(null);
                z.push(null);
            }

            return { x, y, z };
        }

        // Calculate data ranges
        function calculateRanges(center, radius, solvents) {
            const allX = [center[0], ...solvents.map(s => s.coords[0])];
            const allY = [center[1], ...solvents.map(s => s.coords[1])];
            const allZ = [center[2], ...solvents.map(s => s.coords[2])];

            // Add sphere boundaries
            allX.push(center[0] - radius, center[0] + radius);
            allY.push(center[1] - radius, center[1] + radius);
            allZ.push(center[2] - radius, center[2] + radius);

            return {
                x: [Math.min(...allX), Math.max(...allX)],
                y: [Math.min(...allY), Math.max(...allY)],
                z: [Math.min(...allZ), Math.max(...allZ)]
            };
        }

        // Normalize data to [-1,1]
        function normalizeData(center, radius, solvents) {
            const ranges = calculateRanges(center, radius, solvents);

            const globalMin = Math.min(ranges.x[0], ranges.y[0], ranges.z[0]);
            const globalMax = Math.max(ranges.x[1], ranges.y[1], ranges.z[1]);
            const globalRange = globalMax - globalMin;

            const normalize = (value) => 2 * (value - globalMin) / globalRange - 1;

            return {
                center: center.map(normalize),
                radius: 2 * radius / globalRange,
                solvents: solvents.map(s => ({
                    ...s,
                    coords: s.coords.map(normalize)
                })),
                originalData: { center, radius, solvents, globalMin, globalMax, globalRange }
            };
        }

        // Create base traces
        function createBaseTraces(center, radius, solvents, useWireframe = false) {
            const traces = [];

            // Sphere
            if (useWireframe) {
                const wireframe = generateWireframe(center, radius);
                traces.push({
                    type: 'scatter3d',
                    mode: 'lines',
                    x: wireframe.x,
                    y: wireframe.y,
                    z: wireframe.z,
                    line: { color: 'rgba(76, 175, 80, 0.7)', width: 3 },
                    showlegend: false,
                    name: 'Hansen Sphere'
                });
            } else {
                const sphere = generateSphere(center, radius);
                traces.push({
                    type: 'surface',
                    x: sphere.x,
                    y: sphere.y,
                    z: sphere.z,
                    colorscale: [[0, 'rgba(76, 175, 80, 0.3)'], [1, 'rgba(76, 175, 80, 0.3)']],
                    opacity: 0.4,
                    showscale: false,
                    name: 'Hansen Sphere'
                });
            }

            // Solvent points
            traces.push({
                type: 'scatter3d',
                mode: 'markers',
                x: solvents.map(s => s.coords[0]),
                y: solvents.map(s => s.coords[1]),
                z: solvents.map(s => s.coords[2]),
                marker: {
                    size: 6,
                    color: solvents.map(s => s.color),
                    opacity: 0.9
                },
                text: solvents.map(s => s.name),
                name: 'Solvents'
            });

            // Center point
            traces.push({
                type: 'scatter3d',
                mode: 'markers',
                x: [center[0]],
                y: [center[1]],
                z: [center[2]],
                marker: {
                    size: 8,
                    color: '#32CD32',
                    opacity: 1.0
                },
                name: 'HSP Center'
            });

            return traces;
        }

        // Test 1: MixingCompass Simulation
        function test1_MixingCompassSimulation() {
            const traces = createBaseTraces(realData.center, realData.radius, realData.solvents);

            const layout = {
                scene: {
                    aspectmode: 'data',  // This is what MixingCompass is likely using
                    camera: { eye: { x: 1.25, y: 1.25, z: 1.25 } },
                    xaxis: { title: 'δD [MPa^0.5]' },
                    yaxis: { title: 'δP [MPa^0.5]' },
                    zaxis: { title: 'δH [MPa^0.5]' }
                },
                title: 'Test 1: MixingCompass Current (aspectmode: data)',
                width: 600,
                height: 300
            };

            Plotly.newPlot('plot1', traces, layout);

            const ranges = calculateRanges(realData.center, realData.radius, realData.solvents);
            const spans = {
                x: ranges.x[1] - ranges.x[0],
                y: ranges.y[1] - ranges.y[0],
                z: ranges.z[1] - ranges.z[0]
            };

            document.getElementById('test1-info').innerHTML = `
                <strong>Current MixingCompass approach:</strong><br>
                X span: ${spans.x.toFixed(1)}<br>
                Y span: ${spans.y.toFixed(1)}<br>
                Z span: ${spans.z.toFixed(1)}<br>
                <span class="highlight">Y/X ratio: ${(spans.y/spans.x).toFixed(1)}:1</span><br>
                <span class="highlight">Z/X ratio: ${(spans.z/spans.x).toFixed(1)}:1</span>
            `;

            testResults.test1 = { distorted: spans.y > spans.x * 1.5 || spans.z > spans.x * 1.5 };
        }

        // Test 2: Equal Ranges Manual
        function test2_EqualRangesManual() {
            const ranges = calculateRanges(realData.center, realData.radius, realData.solvents);
            const maxSpan = Math.max(
                ranges.x[1] - ranges.x[0],
                ranges.y[1] - ranges.y[0],
                ranges.z[1] - ranges.z[0]
            );

            const equalRanges = {
                x: [realData.center[0] - maxSpan/2, realData.center[0] + maxSpan/2],
                y: [realData.center[1] - maxSpan/2, realData.center[1] + maxSpan/2],
                z: [realData.center[2] - maxSpan/2, realData.center[2] + maxSpan/2]
            };

            const traces = createBaseTraces(realData.center, realData.radius, realData.solvents);

            const layout = {
                scene: {
                    aspectmode: 'manual',
                    aspectratio: { x: 1, y: 1, z: 1 },
                    xaxis: {
                        title: 'δD [MPa^0.5]',
                        range: equalRanges.x
                    },
                    yaxis: {
                        title: 'δP [MPa^0.5]',
                        range: equalRanges.y
                    },
                    zaxis: {
                        title: 'δH [MPa^0.5]',
                        range: equalRanges.z
                    },
                    camera: { eye: { x: 1.25, y: 1.25, z: 1.25 } }
                },
                title: 'Test 2: Equal Ranges (manual + aspectratio)',
                width: 600,
                height: 300
            };

            Plotly.newPlot('plot2', traces, layout);

            document.getElementById('test2-info').innerHTML = `
                <strong>Equal ranges approach:</strong><br>
                Max span: ${maxSpan.toFixed(1)}<br>
                All ranges: ${maxSpan.toFixed(1)}<br>
                X: [${equalRanges.x[0].toFixed(1)}, ${equalRanges.x[1].toFixed(1)}]<br>
                Y: [${equalRanges.y[0].toFixed(1)}, ${equalRanges.y[1].toFixed(1)}]<br>
                Z: [${equalRanges.z[0].toFixed(1)}, ${equalRanges.z[1].toFixed(1)}]
            `;

            testResults.test2 = { distorted: false }; // Should be perfect
        }

        // Test 3: Cube Mode
        function test3_CubeMode() {
            const traces = createBaseTraces(realData.center, realData.radius, realData.solvents);

            const layout = {
                scene: {
                    aspectmode: 'cube',
                    camera: { eye: { x: 1.25, y: 1.25, z: 1.25 } },
                    xaxis: { title: 'δD [MPa^0.5]' },
                    yaxis: { title: 'δP [MPa^0.5]' },
                    zaxis: { title: 'δH [MPa^0.5]' }
                },
                title: 'Test 3: Cube Mode (should fail with unequal data)',
                width: 600,
                height: 300
            };

            Plotly.newPlot('plot3', traces, layout);

            document.getElementById('test3-info').innerHTML = `
                <strong>Cube mode with unequal data:</strong><br>
                This should show the same distortion as Test 1<br>
                Cube mode doesn't work with unequal data ranges
            `;

            testResults.test3 = { distorted: true }; // Expected to fail
        }

        // Test 4: Data Mode + Invisible Points
        function test4_DataModeInvisible() {
            const traces = createBaseTraces(realData.center, realData.radius, realData.solvents);

            // Add invisible boundary points
            const ranges = calculateRanges(realData.center, realData.radius, realData.solvents);
            const maxSpan = Math.max(
                ranges.x[1] - ranges.x[0],
                ranges.y[1] - ranges.y[0],
                ranges.z[1] - ranges.z[0]
            );

            traces.unshift({
                type: 'scatter3d',
                mode: 'markers',
                x: [
                    realData.center[0] - maxSpan/2, realData.center[0] + maxSpan/2,
                    realData.center[0] - maxSpan/2, realData.center[0] + maxSpan/2
                ],
                y: [
                    realData.center[1] - maxSpan/2, realData.center[1] + maxSpan/2,
                    realData.center[1] - maxSpan/2, realData.center[1] + maxSpan/2
                ],
                z: [
                    realData.center[2] - maxSpan/2, realData.center[2] + maxSpan/2,
                    realData.center[2] - maxSpan/2, realData.center[2] + maxSpan/2
                ],
                marker: { size: 1, opacity: 0 },
                showlegend: false,
                hoverinfo: 'skip'
            });

            const layout = {
                scene: {
                    aspectmode: 'data',
                    camera: { eye: { x: 1.25, y: 1.25, z: 1.25 } },
                    xaxis: { title: 'δD [MPa^0.5]' },
                    yaxis: { title: 'δP [MPa^0.5]' },
                    zaxis: { title: 'δH [MPa^0.5]' }
                },
                title: 'Test 4: Data Mode + Invisible Boundary Points',
                width: 600,
                height: 300
            };

            Plotly.newPlot('plot4', traces, layout);

            document.getElementById('test4-info').innerHTML = `
                <strong>Data mode + invisible points:</strong><br>
                Added invisible points at equal boundaries<br>
                This forces equal data ranges for aspectmode: 'data'
            `;

            testResults.test4 = { distorted: false }; // Should work
        }

        // Test 5: Normalized Coordinates
        function test5_NormalizedCoordinates() {
            const normalized = normalizeData(realData.center, realData.radius, realData.solvents);
            const traces = createBaseTraces(normalized.center, normalized.radius, normalized.solvents);

            const layout = {
                scene: {
                    aspectmode: 'cube',
                    camera: { eye: { x: 1.25, y: 1.25, z: 1.25 } },
                    xaxis: { title: 'δD (normalized)' },
                    yaxis: { title: 'δP (normalized)' },
                    zaxis: { title: 'δH (normalized)' }
                },
                title: 'Test 5: Fully Normalized Data [-1,1]',
                width: 600,
                height: 300
            };

            Plotly.newPlot('plot5', traces, layout);

            document.getElementById('test5-info').innerHTML = `
                <strong>Normalized coordinates:</strong><br>
                All data mapped to [-1, 1] range<br>
                Original range: ${normalized.originalData.globalRange.toFixed(1)}<br>
                This should be a perfect sphere
            `;

            testResults.test5 = { distorted: false }; // Should be perfect
        }

        // Test 6: Wireframe Only
        function test6_WireframeOnly() {
            const traces = createBaseTraces(realData.center, realData.radius, realData.solvents, true);

            const layout = {
                scene: {
                    aspectmode: 'cube',
                    camera: { eye: { x: 1.25, y: 1.25, z: 1.25 } },
                    xaxis: { title: 'δD [MPa^0.5]' },
                    yaxis: { title: 'δP [MPa^0.5]' },
                    zaxis: { title: 'δH [MPa^0.5]' }
                },
                title: 'Test 6: Wireframe Only (no surface distortion)',
                width: 600,
                height: 300
            };

            Plotly.newPlot('plot6', traces, layout);

            document.getElementById('test6-info').innerHTML = `
                <strong>Wireframe approach:</strong><br>
                Lines only, no surface plot<br>
                Should show if distortion is surface-specific<br>
                or affects all rendering modes
            `;

            testResults.test6 = { distorted: true }; // Will show if it's surface-specific
        }

        function runAllTests() {
            document.getElementById('analysis').innerHTML = 'Running comprehensive tests...';

            test1_MixingCompassSimulation();
            test2_EqualRangesManual();
            test3_CubeMode();
            test4_DataModeInvisible();
            test5_NormalizedCoordinates();
            test6_WireframeOnly();

            document.getElementById('analysis').innerHTML = `
                <strong>All tests completed!</strong><br>
                Review each test to identify which approaches produce perfect spheres.<br>
                <br>
                <strong>Key Data Analysis:</strong><br>
                Center: (${realData.center[0].toFixed(1)}, ${realData.center[1].toFixed(1)}, ${realData.center[2].toFixed(1)})<br>
                Radius: ${realData.radius.toFixed(1)}<br>
                <br>
                <strong>Expected Results:</strong><br>
                • Test 1 & 3: Distorted (current MixingCompass)<br>
                • Test 2, 4, 5: Perfect spheres (solutions)<br>
                • Test 6: Shows if problem is surface-specific
            `;
        }

        function testMixingCompassExact() {
            // This would fetch real data if server is running
            console.log('Real MixingCompass data:', realData);
            runAllTests();
        }

        function generateReport() {
            let report = '<h3>Sphere Distortion Analysis Report</h3>';

            // Analyze which tests worked
            const workingTests = [];
            const failedTests = [];

            Object.entries(testResults).forEach(([test, result]) => {
                if (result.distorted) {
                    failedTests.push(test);
                } else {
                    workingTests.push(test);
                }
            });

            report += `
                <strong>Working Solutions:</strong> ${workingTests.join(', ')}<br>
                <strong>Failed Approaches:</strong> ${failedTests.join(', ')}<br>
                <br>
                <strong>Recommended Fix for MixingCompass:</strong><br>
                Based on the working tests, implement the approach from Test 2:<br>
                1. Calculate maximum span across all axes<br>
                2. Set equal ranges for all axes centered on HSP center<br>
                3. Use aspectmode: 'manual' with aspectratio: {x:1, y:1, z:1}<br>
                4. Apply manual axis ranges<br>
                <br>
                This should guarantee a perfect sphere regardless of data distribution.
            `;

            document.getElementById('report').style.display = 'block';
            document.getElementById('reportContent').innerHTML = report;
        }

        // Auto-run tests on page load
        window.onload = () => {
            setTimeout(runAllTests, 1000);
        };
    </script>
</body>
</html>