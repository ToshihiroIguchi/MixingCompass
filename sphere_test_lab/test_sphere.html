<!DOCTYPE html>
<html>
<head>
    <title>Hansen Sphere Test Lab</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .test-container { margin-bottom: 40px; border: 1px solid #ccc; padding: 20px; }
        .plot-container { width: 600px; height: 400px; margin: 10px 0; }
        h2 { color: #333; }
        .description { color: #666; margin-bottom: 10px; }
    </style>
</head>
<body>
    <h1>Hansen Sphere Rendering Test Lab</h1>

    <div class="test-container">
        <h2>Test 1: Basic Surface Plot (Standard)</h2>
        <div class="description">Standard Plotly surface with aspectmode: 'cube'</div>
        <div id="plot1" class="plot-container"></div>
    </div>

    <div class="test-container">
        <h2>Test 2: Surface with Manual Aspect Ratio</h2>
        <div class="description">Surface with aspectmode: 'manual' and forced 1:1:1 ratio</div>
        <div id="plot2" class="plot-container"></div>
    </div>

    <div class="test-container">
        <h2>Test 3: Surface with Data Aspect + Invisible Points</h2>
        <div class="description">Surface with aspectmode: 'data' and invisible corner points</div>
        <div id="plot3" class="plot-container"></div>
    </div>

    <div class="test-container">
        <h2>Test 4: Wireframe Lines Only</h2>
        <div class="description">Scatter3D lines (no surface) with meridians and parallels</div>
        <div id="plot4" class="plot-container"></div>
    </div>

    <div class="test-container">
        <h2>Test 5: Mesh3D (Alternative)</h2>
        <div class="description">Mesh3D plot as alternative to surface</div>
        <div id="plot5" class="plot-container"></div>
    </div>

    <script>
        // Test parameters
        const center = [15, 8, 12];
        const radius = 5;

        // Generate sphere surface coordinates
        function generateSphereSurface(center, radius, resolution = 20) {
            const u = [];
            const v = [];
            for (let i = 0; i < resolution; i++) {
                u.push(2 * Math.PI * i / (resolution - 1));
                v.push(Math.PI * i / (resolution - 1));
            }

            const x = [];
            const y = [];
            const z = [];

            for (let i = 0; i < resolution; i++) {
                const xRow = [];
                const yRow = [];
                const zRow = [];
                for (let j = 0; j < resolution; j++) {
                    xRow.push(center[0] + radius * Math.cos(u[j]) * Math.sin(v[i]));
                    yRow.push(center[1] + radius * Math.sin(u[j]) * Math.sin(v[i]));
                    zRow.push(center[2] + radius * Math.cos(v[i]));
                }
                x.push(xRow);
                y.push(yRow);
                z.push(zRow);
            }

            return { x, y, z };
        }

        // Generate wireframe coordinates
        function generateSphereWireframe(center, radius, resolution = 30) {
            const x = [];
            const y = [];
            const z = [];

            // Meridians
            const nMeridians = 12;
            for (let i = 0; i < nMeridians; i++) {
                const phi = 2 * Math.PI * i / nMeridians;
                for (let j = 0; j < resolution; j++) {
                    const theta = Math.PI * j / (resolution - 1);
                    x.push(center[0] + radius * Math.sin(theta) * Math.cos(phi));
                    y.push(center[1] + radius * Math.sin(theta) * Math.sin(phi));
                    z.push(center[2] + radius * Math.cos(theta));
                }
                x.push(null);
                y.push(null);
                z.push(null);
            }

            // Parallels
            const nParallels = 6;
            for (let i = 1; i < nParallels; i++) {
                const theta = Math.PI * i / nParallels;
                for (let j = 0; j < resolution; j++) {
                    const phi = 2 * Math.PI * j / (resolution - 1);
                    x.push(center[0] + radius * Math.sin(theta) * Math.cos(phi));
                    y.push(center[1] + radius * Math.sin(theta) * Math.sin(phi));
                    z.push(center[2] + radius * Math.cos(theta));
                }
                x.push(null);
                y.push(null);
                z.push(null);
            }

            return { x, y, z };
        }

        // Test 1: Basic Surface
        const sphereCoords1 = generateSphereSurface(center, radius);
        Plotly.newPlot('plot1', [{
            type: 'surface',
            x: sphereCoords1.x,
            y: sphereCoords1.y,
            z: sphereCoords1.z,
            colorscale: 'Greens',
            opacity: 0.7,
            showscale: false
        }], {
            scene: {
                aspectmode: 'cube',
                camera: { eye: { x: 1.5, y: 1.5, z: 1.5 } }
            },
            title: 'Test 1: Standard Surface (aspectmode: cube)'
        });

        // Test 2: Manual Aspect Ratio
        Plotly.newPlot('plot2', [{
            type: 'surface',
            x: sphereCoords1.x,
            y: sphereCoords1.y,
            z: sphereCoords1.z,
            colorscale: 'Greens',
            opacity: 0.7,
            showscale: false
        }], {
            scene: {
                aspectmode: 'manual',
                aspectratio: { x: 1, y: 1, z: 1 },
                camera: { eye: { x: 1.5, y: 1.5, z: 1.5 } }
            },
            title: 'Test 2: Manual Aspect Ratio'
        });

        // Test 3: Data Aspect + Invisible Points
        const invisiblePoints = {
            type: 'scatter3d',
            mode: 'markers',
            x: [center[0] - radius, center[0] + radius, center[0] - radius, center[0] + radius],
            y: [center[1] - radius, center[1] + radius, center[1] - radius, center[1] + radius],
            z: [center[2] - radius, center[2] + radius, center[2] - radius, center[2] + radius],
            marker: { size: 1, opacity: 0 },
            showlegend: false,
            hoverinfo: 'skip'
        };

        Plotly.newPlot('plot3', [
            invisiblePoints,
            {
                type: 'surface',
                x: sphereCoords1.x,
                y: sphereCoords1.y,
                z: sphereCoords1.z,
                colorscale: 'Greens',
                opacity: 0.7,
                showscale: false
            }
        ], {
            scene: {
                aspectmode: 'data',
                camera: { eye: { x: 1.5, y: 1.5, z: 1.5 } }
            },
            title: 'Test 3: Data Aspect + Invisible Points'
        });

        // Test 4: Wireframe Only
        const wireframe = generateSphereWireframe(center, radius);
        Plotly.newPlot('plot4', [{
            type: 'scatter3d',
            mode: 'lines',
            x: wireframe.x,
            y: wireframe.y,
            z: wireframe.z,
            line: { color: 'green', width: 3 },
            showlegend: false
        }], {
            scene: {
                aspectmode: 'cube',
                camera: { eye: { x: 1.5, y: 1.5, z: 1.5 } }
            },
            title: 'Test 4: Wireframe Lines Only'
        });

        // Test 5: Mesh3D
        // Generate vertices for icosphere (simplified)
        const vertices = [];
        const faces = [];

        // Simple approach: generate points on sphere surface
        const meshResolution = 10;
        for (let i = 0; i < meshResolution; i++) {
            for (let j = 0; j < meshResolution; j++) {
                const phi = 2 * Math.PI * i / meshResolution;
                const theta = Math.PI * j / meshResolution;
                vertices.push([
                    center[0] + radius * Math.sin(theta) * Math.cos(phi),
                    center[1] + radius * Math.sin(theta) * Math.sin(phi),
                    center[2] + radius * Math.cos(theta)
                ]);
            }
        }

        const meshX = vertices.map(v => v[0]);
        const meshY = vertices.map(v => v[1]);
        const meshZ = vertices.map(v => v[2]);

        Plotly.newPlot('plot5', [{
            type: 'mesh3d',
            x: meshX,
            y: meshY,
            z: meshZ,
            color: 'lightgreen',
            opacity: 0.7
        }], {
            scene: {
                aspectmode: 'cube',
                camera: { eye: { x: 1.5, y: 1.5, z: 1.5 } }
            },
            title: 'Test 5: Mesh3D Alternative'
        });

    </script>
</body>
</html>